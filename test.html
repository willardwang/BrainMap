<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>五角星</title>
        <script>
            /**
             * 画五角星
             * @param ctx
             * @param r 内圆半径
             * @param R 外圆半径
             * @param x 圆心横坐标
             * @param y 圆心纵坐标
             * @param rot 旋转角度
             */
            function drawStar(ctx, r, R, x, y, rot) {
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72 - rot) / 180 * Math.PI) * R + x,
                        -Math.sin((18 + i * 72 - rot) / 180 * Math.PI) * R + y);
                    ctx.lineTo(Math.cos((54 + i * 72 - rot) / 180 * Math.PI) * r + x,
                        -Math.sin((54 + i * 72 - rot) / 180 * Math.PI) * r + y);
                }
                ctx.closePath();
                // ctx.stroke();//不要边框
                var gradient = ctx.createRadialGradient(x, y, R, x, y, 0);
                gradient.addColorStop(0, "rgba(179,144,144,1)");
                gradient.addColorStop(1, "white");
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            function loaded() {
                var canvas = document.getElementById("canvas");
                var frontCtx = canvas.getContext("2d");
                // drawStar(frontCtx, 60, 200, 300, 300, 200);
                var from = {x: 600, y: 100};
                var to = {x: 400, y: 50};
                //光亮处的初始位置：三分之一处的坐标
                var startX;
                var startY;
                //光亮处的初始位置：三分之二处的坐标
                var endX;
                var endY;
                if ((from.x < to.x && from.y < to.y) || (to.x < from.x && to.y < from.y)) {
                    startX = Math.min(from.x, to.x) + Math.abs(from.x - to.x) / 3;
                    startY = Math.min(from.y, to.y) + Math.abs(from.y - to.y) / 3;
                    endX = Math.min(from.x, to.x) + Math.abs(from.x - to.x) / 3 * 2;
                    endY = Math.min(from.y, to.y) + Math.abs(from.y - to.y) / 3 * 2;
                }
                if ((from.x > to.x && from.y < to.y) || (from.x < to.x && from.y > to.y)) {
                    startX = Math.min(from.x, to.x) + Math.abs(from.x - to.x) / 3;
                    startY = Math.min(from.y, to.y) + Math.abs(from.y - to.y) / 3 * 2;
                    endX = Math.min(from.x, to.x) + Math.abs(from.x - to.x) / 3 * 2;
                    endY = Math.min(from.y, to.y) + Math.abs(from.y - to.y) / 3;
                }
                if (from.x = to.x) {
                    if (from.y === to.y) {
                        console.log('点重合错误');
                    }
                    startX = from.x;//or startX = to.x
                    startY = Math.min(from.y, to.y) + Math.abs(from.y - to.y) / 3;
                    endX = from.x;//or endX = to.x
                    endY = Math.min(from.y, to.y) + Math.abs(from.y - to.y) / 3 * 2;
                }
                if (from.y === to.y) {
                    if (from.x === to.x) {
                        console.log('点重合错误');
                    }
                    startX = Math.min(from.x, to.x) + Math.abs(from.x - to.x) / 3;
                    startY = from.y;//or startY = to.y
                    endX = Math.min(from.x, to.x) + Math.abs(from.x - to.x) / 3 * 2;
                    endY = from.y;//or endY = to.y
                }
                window.requestAnimationFrame(drawLightLine)

                function drawLightLine() {
                    frontCtx.clearRect(0, 0, canvas.width, canvas.height);
                    frontCtx.beginPath();
                    frontCtx.moveTo(from.x, from.y);
                    frontCtx.lineTo(to.x, to.y);
                    frontCtx.strokeStyle = "red";
                    frontCtx.stroke();
                    frontCtx.closePath();
                    /*
                    * 斜线方程
                    *   y = k*x + b
                    * 代入两个点
                    *   y1 = k * x1 + b
                    *   y2 = k * x2 + b
                    * 求k
                    *   y1 - y2 = k * (x1 - x2)
                    *   k = (y1 - y2) / (x1 - x2)
                    * 求b
                    *   b = y1 - ((y1 - y2) / (x1 - x2)) * x1
                    *   b = y1 - (y1 * x1 - y2 * x1)/(x1 - x2)
                    *   b = (y1 * x1 - y1 * x2 - y1 * x1 + y2 * x1) /  (x1 - x2)
                    *   b = (y2 * x1 - y1 * x2) / (x1 - x2)
                    */
                    /*
                    * 中点垂直斜线方程
                    * 已知斜线方程为k，则垂直斜线斜率为-1 / k
                    *   k = -1 / ((y1 - y2) / (x1 - x2))
                    *   k = (x2 - x1) / (y1 - y2)
                    * 中点坐标为x: (x1 + x2) / 2 y: (y1 + y2) / 2
                    * 将中点带入方程
                    *   (y1 + y2) / 2 = (-1 / ((y1 - y2) / (x1 - x2))) *  ((x1 + x2) / 2) + b
                    *   (y1 + y2) / 2 = (-1 * (x1 - x2) / (y1 - y2)) *  ((x1 + x2) / 2) + b
                    *   (y1 + y2) / 2 = ((x2 - x1) / (y1 - y2)) *  ((x1 + x2) / 2) + b
                    *   b = (y1 + y2) / 2 - ((x2 - x1) / (y1 - y2)) *  ((x1 + x2) / 2)
                    *
                    * 假设距离为L，求点的坐标为x,y，已知点坐标为x0,y0，根据勾股定理可得如下一元二次方程
                    *   (y - y0)^2 + (x - x0)^2 = L^2
                    * 联合中点垂直斜线的方程
                    *   y = kx + b
                    * 代入y，得x的一元二次方程：
                    *   (k^2+1)x^2+2[(b-y0)k-x0]x+[(b-y0)^2+x0^2-L^2]=0
                    * 一元二次方程Ax^2+Bx+C=0中,
                    * 一元二次方程求根公式：
                    *   x1,x2= [-B±√(B^2-4AC)]/2A
                    * */
                    let k = (endX - startX) / (startY - endY);//k = (x2 - x1) / (y1 - y2)
                    let b = (startY + endY) / 2 - ((endX - startX) / (startY - endY)) * ((startX + endX) / 2);//(y1 + y2) / 2 - ((x2 - x1) / (y1 - y2)) *  ((x1 + x2) / 2)
                    let centerX = (startX + endX) / 2;
                    let centerY = (startY + endY) / 2;
                    let A = Math.pow(k, 2) + 1;//(k^2+1)
                    let B = 2 * ((b - centerY) * k - centerX);// B=2[(b-y0)k-x0];
                    let C = Math.pow(b - centerY, 2) + Math.pow(centerX, 2) - Math.pow(2, 2);// C=(b-y0)^2+x0^2-L^2
                    let x1 = (-B + Math.sqrt(Math.pow(B, 2) - 4 * A * C)) / (2 * A);
                    let x2 = (-B - Math.sqrt(Math.pow(B, 2) - 4 * A * C)) / (2 * A);
                    let y1 = k * x1 + b;//y = kx + b
                    let y2 = k * x2 + b;//y = kx + b
                    frontCtx.beginPath();
                    //从中点处向左右各偏移2像素，形成菱形
                    frontCtx.moveTo(startX, startY);
                    frontCtx.lineTo(x1, y1);
                    frontCtx.lineTo(endX, endY);
                    frontCtx.lineTo(x2, y2);
                    frontCtx.lineTo(startX, startY);
                    frontCtx.closePath();
                    let gradient = frontCtx.createRadialGradient(startX, startY, 5, endX, endY, 5);
                    gradient.addColorStop(0, "white");
                    gradient.addColorStop(1, "white");
                    frontCtx.fillStyle = gradient;
                    frontCtx.fill();
                    // debugger
                    //z轴移动step像素，计算投影
                    let step = 0.5;
                    //斜边step在x轴上的投影
                    let widthStep = calWidthStep(from.x, from.y, to.x, to.y, step);
                    if (to.x > from.x) {
                        startX += widthStep;
                        endX += widthStep;
                    } else if (to.x < from.x) {
                        startX -= widthStep;
                        endX -= widthStep;
                    }
                    //斜边在y轴上的投影
                    let heightStep = calHeightStep(from.x, from.y, to.x, to.y, step);
                    if (to.y > from.y) {
                        startY += heightStep;
                        endY += heightStep;
                    } else if (to.y < from.y) {
                        startY -= heightStep;
                        endY -= heightStep;
                    }
                    window.requestAnimationFrame(drawLightLine)
                }
            }

            /**
             * 计算斜边step在x轴上的投影
             */
            function calWidthStep(x1, y1, x2, y2, step) {
                let dx = Math.abs(x2 - x1);
                let dy = Math.abs(y2 - y1);
                if (dx === 0) {
                    return 0;
                }
                if (dy === 0) {
                    return step;
                }
                let dz = Math.sqrt(dx * dx + dy * dy);//斜边
                return dx * step / dz;
            }

            /**
             * 计算斜边step在y轴上的投影
             */
            function calHeightStep(x1, y1, x2, y2, step) {
                let dx = Math.abs(x2 - x1);
                let dy = Math.abs(y2 - y1);
                if (dx === 0) {
                    return step;
                }
                if (dy === 0) {
                    return 0;
                }
                let dz = Math.sqrt(dx * dx + dy * dy);//斜边
                return dy * step / dz;
            }
        </script>
    </head>
    <body onload="loaded()">
        <canvas id="canvas" width="1800" height="1800" style="background: #000000;color: red;"></canvas>
    </body>
</html>